// This file generated by the "make_python_ext.pl" script.  Don't edit here!

/* RTcmix - Copyright (C) 2004  The RTcmix Development Team
   See ``AUTHORS'' for a list of contributors. See ``LICENSE'' for
   the license to this software and for a DISCLAIMER OF ALL WARRANTIES.
*/

/* This Python extension has two purposes.

      1. It lets a Python script call RTcmix functions, when RTcmix
         embeds the Python interpreter.

      2. It lets a Python script use variables that refer to RTcmix
         Handles, which contain references to PField and other
         future types of object.  Some of the arithmetic operators
         are overloaded for use with these objects.

   The module is called "rtcmix"; the object is called OpaqueObject,
   which wraps an RTcmix Handle.  Some RTcmix functions return a
   Handle to the script.

                                                John Gibson, 7/4/04

   Revised for python3 by Aaron Stepp and John Gibson, September 2022
*/

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#if defined(PY_MAJOR_VERSION) && PY_VERSION_HEX < 0x03080000
#error "******** You need Python 3.8 or greater ********"
#endif

#include <rtcmix_types.h>
#include <PField.h>
#include <utils.h>
#include <math.h>
#include "../../include/maxdispargs.h"
#include "../../rtcmix/prototypes.h"
#include "../../rtcmix/RTcmix.h"

static PyObject *ErrorObject;


// -- Opaque object -----------------------------------------------------------

typedef struct {
   PyObject_HEAD
   PyObject *attrDict;    // Attributes dictionary
   Handle handle;
} OpaqueObject;

// forward declarations
static void Opaque_dealloc(OpaqueObject *self);
static PyObject *Opaque_getattr(OpaqueObject *self, const char *name);
static int Opaque_setattr(OpaqueObject *self, const char *name, PyObject *obj);
static PyObject *Opaque_add(PyObject *a, PyObject *b);
static PyObject *Opaque_subtract(PyObject *a, PyObject *b);
static PyObject *Opaque_multiply(PyObject *a, PyObject *b);
static PyObject *Opaque_divide(PyObject *a, PyObject *b);
static PyObject *Opaque_remainder(PyObject *a, PyObject *b);
static PyObject *Opaque_power(PyObject *a, PyObject *b, PyObject *c);
static PyObject *Opaque_neg(PyObject *a);
static PyObject *Opaque_not_implemented(void);

static PyNumberMethods Opaque_as_number = {
	.nb_add = (binaryfunc) Opaque_add,
   .nb_subtract = (binaryfunc) Opaque_subtract,
   .nb_multiply = (binaryfunc) Opaque_multiply,
	.nb_remainder = (binaryfunc) Opaque_remainder,
	.nb_divmod = (binaryfunc) Opaque_divide,
	.nb_power = (ternaryfunc) Opaque_power,
	.nb_negative = (unaryfunc) Opaque_neg,
	.nb_positive = (unaryfunc) Opaque_not_implemented,
	.nb_absolute = (unaryfunc) Opaque_not_implemented,
};

static PyTypeObject OpaqueType = {
   PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "rtcmix.Opaque",
	.tp_basicsize = sizeof(OpaqueObject),
	.tp_itemsize = 0,
	.tp_dealloc = (destructor) Opaque_dealloc,
   .tp_getattr = (getattrfunc) Opaque_getattr,
   .tp_setattr = (setattrfunc) Opaque_setattr,
	.tp_as_number = &Opaque_as_number,
   .tp_flags = Py_TPFLAGS_BASETYPE,		// was Py_TPFLAGS_CHECKTYPES
   .tp_doc = PyDoc_STR("Handle objects"),
	//.tp_new = PyType_GenericNew,
};


inline bool OpaqueObject_Check(PyObject *obj)
{
   return (Py_TYPE(obj)	== &OpaqueType);
}

static OpaqueObject *newOpaqueObject(PyObject *arg)
{
   OpaqueObject *self = PyObject_NEW(OpaqueObject, &OpaqueType);
   if (self == NULL)
      return NULL;

   self->attrDict = NULL;
   self->handle = NULL;

   return self;
}

static void Opaque_dealloc(OpaqueObject *self)
{
// printf("Opaque_dealloc: %p\n", self);
   if (self->handle)
      unrefHandle(self->handle);
   Py_XDECREF(self->attrDict);
   PyObject_Del(self);
}


// Return a Handle from a PyObject, which MUST be an OpaqueObject.
inline Handle HandleFromPyObject(PyObject *obj)
{
   return ((OpaqueObject *) obj)->handle;
}


// Return a PField from a PyObject, or NULL if the object does not represent
// either a PField Handle or a number.
static PField *PFieldFromPyObject(PyObject *obj)
{
   PField *pfield;
   if (OpaqueObject_Check(obj)) {
      Handle handle = HandleFromPyObject(obj);
      if (handle->type != PFieldType) {
         PyErr_SetString(PyExc_TypeError,
                           "can't operate on a Handle that is not a PField");
         return NULL;
      }
      pfield = (PField *) handle->ptr;
   }
   else {
      if (!PyNumber_Check(obj)) {
         PyErr_SetString(PyExc_TypeError,
                         "can operate only with PField Handles and numbers.");
         return NULL;
      }
      double val = PyFloat_AsDouble(obj);
      pfield = new ConstPField(val);
   }
   return pfield;
}


// -- Opaque object methods ---------------------------------------------------

/* This is where to write methods that could be called on our Opaque object:
   maybe ways to see what type it is, its values, etc.
   This is NOT the place to list rtcmix functions (see _rtcmix_methods below).
*/

#ifdef NOTYET
static PyObject *Opaque_type(OpaqueObject *self, PyObject *args)
{
   const char *str = NULL;

   if (!PyArg_ParseTuple(args, ":type"))
      return NULL;
   
   Handle handle = HandleFromPyObject((PyObject *) self);
   if (handle->type == PFieldType)
      str = "PField";
   else if (handle->type == InstrumentPtrType)
      str = "Instrument";
   else if (handle->type == ListType)
      str = "List";
   else
      str = "(invalid)";
   return PyUnicode_FromString(str);
}

static PyMethodDef Opaque_methods[] = {
   {"type", (PyCFunction) Opaque_type, METH_VARARGS},
   {NULL, NULL}      // sentinel
};
#endif //NOTYET

static PyObject *Opaque_getattr(OpaqueObject *self, const char *name)
{
   if (self->attrDict != NULL) {
      PyObject *obj = PyDict_GetItemString(self->attrDict, name);
      if (obj != NULL) {
         Py_INCREF(obj);
         return obj;
      }
   }
//FIXME: shouldn't we still do FindMethod and fall back to GenericGetAttr if not found?
   //return Py_FindMethod(Opaque_methods, (PyObject *) self, (char *) name);
   return PyObject_GenericGetAttr((PyObject *) self, PyUnicode_FromString(name));
}

static int Opaque_setattr(OpaqueObject *self, const char *name, PyObject *obj)
{
   if (self->attrDict == NULL) {
      self->attrDict = PyDict_New();
      if (self->attrDict == NULL)
         return -1;
   }
   if (obj == NULL) {
      int rv = PyDict_DelItemString(self->attrDict, name);
      if (rv < 0)
         PyErr_SetString(PyExc_AttributeError,
                         "delete non-existing Opaque attribute");
      return rv;
   }
   else
      return PyDict_SetItemString(self->attrDict, name, obj);
}


// -- Opaque object number methods --------------------------------------------

static double plus_binop(double x, double y) { return x + y; }
static double minus_binop(double x, double y) { return x - y; }
static double mult_binop(double x, double y) { return x * y; }
static double divide_binop(double x, double y) { return (y != 0.0)
                                             ? x / y : 999999999999999999.9; }
static double mod_binop(double x, double y) { return fmod(x, y); }
static double pow_binop(double x, double y) { return pow(x, y); }

typedef enum {
   OpPlus,
   OpMinus,
   OpMul,
   OpDiv,
   OpMod,
   OpPow,
   OpNeg
} NumberOp;


// Create and return appropriate binary operator PField
static PField *createBinopPField(PField *pfield1, PField *pfield2, NumberOp op)
{
   PFieldBinaryOperator::Operator binop = NULL;
  
   switch (op) {
      case OpPlus:
         binop = plus_binop;
         break;
      case OpMinus:
         binop = minus_binop;
         break;
      case OpMul:
         binop = mult_binop;
         break;
      case OpDiv:
         binop = divide_binop;
         break;
      case OpMod:
         binop = mod_binop;
         break;
      case OpPow:
         binop = pow_binop;
         break;
      case OpNeg:
         binop = mult_binop;  // assumes one pfield is ConstPField w/ val == -1
         break;
      default:
         assert("invalid binary handle operator");
         return NULL;
   }
   return new PFieldBinaryOperator(pfield1, pfield2, binop);
}


static PyObject *
_do_numop(PyObject *a, PyObject *b, NumberOp op)
{
   PField *pfield1 = PFieldFromPyObject(a);
   PField *pfield2 = PFieldFromPyObject(b);
   if (pfield1 == NULL || pfield2 == NULL) {
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }

   PField *opfield = createBinopPField(pfield1, pfield2, op);

   OpaqueObject *newobj = newOpaqueObject(NULL);
   if (newobj == NULL) {
      PyErr_SetString(PyExc_TypeError, "can't allocate new Handle");
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }
   newobj->handle = createPFieldHandle(opfield);

   return (PyObject *) newobj;
}


static PyObject *
Opaque_add(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpPlus);
}

static PyObject *
Opaque_subtract(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpMinus);
}

static PyObject *
Opaque_multiply(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpMul);
}

static PyObject *
Opaque_divide(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpDiv);
}

static PyObject *
Opaque_remainder(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpMod);
}

#ifdef NOTYET
static PyObject *
Opaque_divmod(PyObject *a, PyObject *b)
{
   // FIXME: should return 2-tuple of (quotient, remainder)?
}
#endif

static PyObject *
Opaque_power(PyObject *a, PyObject *b, PyObject *c)
{
   // FIXME: <c> is optional modulo, which we ignore here
   return _do_numop(a, b, OpPow);
}

static PyObject *
Opaque_neg(PyObject *a)
{
   if (!OpaqueObject_Check(a)) {          // not sure how this could happen
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }

   Handle handle = HandleFromPyObject(a);
   if (handle->type != PFieldType) {
      PyErr_SetString(PyExc_TypeError,
                        "can't negate a Handle that is not a PField");
      return NULL;
   }

   PField *pfield1 = (PField *) handle->ptr;
   PField *pfield2 = new ConstPField(-1.0);
   PField *opfield = createBinopPField(pfield1, pfield2, OpMul);

   OpaqueObject *newobj = newOpaqueObject(NULL);
   if (newobj == NULL) {
      PyErr_SetString(PyExc_TypeError, "can't allocate new Handle");
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }
   newobj->handle = createPFieldHandle(opfield);

   return (PyObject *) newobj;
}

static PyObject *
Opaque_not_implemented(void)
{
   PyErr_SetString(PyExc_TypeError, "operator not implemented for Handle");
   Py_INCREF(Py_NotImplemented);
   return Py_NotImplemented;
}


// -- rtcmix module -----------------------------------------------------------

static Arg * append_list_to_arglist(const char *funcname, PyObject *obj, Arg *inArgs, int *pNumArgs)
{
   // NB: length of new list is oldlen + inListLen - 1, because last slot
   // is replaced by the first value of the array we're appending. Note that
   // *pNumArgs is actually the length of old arg list - 1.
   int inListLen;
   if (PyTuple_Check(obj))
      inListLen = PyTuple_Size(obj);
   else
      inListLen = PyList_Size(obj);
   int oldNumArgs = *pNumArgs;
   int n = 0, newNumArgs = oldNumArgs + inListLen;
   // Create expanded array
   Arg *newArgs = new Arg[newNumArgs];
   if (newArgs == NULL)
      return NULL;
   if (inArgs != NULL) {
      // Copy existing args to new array
      for (; n < oldNumArgs; ++n) {
         newArgs[n] = inArgs[n];
      }
   }
   for (int i = 0; n < newNumArgs; ++i, ++n) {
      PyObject *item;
      if (PyTuple_Check(obj))
         item = PyTuple_GET_ITEM(obj, i);
      else
         item = PyList_GET_ITEM(obj, i);
      if (PyNumber_Check(item))
         newArgs[n] = PyFloat_AsDouble(item);
      else if (PyUnicode_Check(item)) {
// FIXME: leak -- not necessary, because StringPField dups string?
			PyObject *bytes = PyUnicode_AsUTF8String(obj);
         char *str = strdup(PyBytes_AsString(bytes));
         newArgs[n] = str;
			Py_DECREF(bytes);
      }
      else if (OpaqueObject_Check(item)) {
         Handle handle = HandleFromPyObject(item);
         if (handle->type != PFieldType && handle->type != InstrumentPtrType) {
            PyErr_SetString(PyExc_TypeError, "invalid RTcmix Handle type");
            return NULL;
         }
         newArgs[n] = handle;
      }
      else {
         PyErr_SetString(PyExc_TypeError, "cannot expand lists that include "
            "anything other than numbers and strings.");
         newArgs[n] = 0.0;
      }
   }
   *pNumArgs = newNumArgs;
   return newArgs;
}

static PyObject *_call_dispatch(PyObject *args, const char *funcname)
{
   if (!PyTuple_Check(args))
      return NULL;

   int nargs = PyTuple_Size(args);
   if (nargs > MAXDISPARGS) {
      char buf[256];
      snprintf(buf, 256, "too many arguments to '%s'", funcname);
      PyErr_SetString(PyExc_TypeError, buf);
      return NULL;
   }
   int numArgs = nargs;

   Arg *rtcmixargs = new Arg[nargs];
   if (rtcmixargs == NULL)
      return NULL;

   for (int i = 0; i < nargs; i++) {
      PyObject *obj = PyTuple_GET_ITEM(args, i);
      if (OpaqueObject_Check(obj)) {
         Handle handle = HandleFromPyObject(obj);
         if (handle->type != PFieldType && handle->type != InstrumentPtrType && handle->type != ListType) {
            PyErr_SetString(PyExc_TypeError, "invalid RTcmix Handle type");
            return NULL;
         }
         rtcmixargs[i] = handle;
      }
      else if (PyNumber_Check(obj)) {
         double val = PyFloat_AsDouble(obj);
         rtcmixargs[i] = val;
#ifdef DEBUG
         printf("%d: %8f\n", i, val);
#endif
      }
      else if (PyUnicode_Check(obj)) {
         // dup the string, because we'll kill interpreter before
         // insts have run.
// FIXME: leak -- not necessary, because StringPField dups string?
// FIXME: or is it _AsASCIIString or _AsLatin1String, etc.?
			PyObject *bytes = PyUnicode_AsUTF8String(obj);
         char *str = strdup(PyBytes_AsString(bytes));
         rtcmixargs[i] = str;
			Py_DECREF(bytes);
#ifdef DEBUG
         printf("%d: \"%s\"\n", i, str);
#endif
      }
      // NOTE: The memory allocated below is free'd right after the dispatch
      // call, during "delete rtcmixargs" (in Arg::~Arg).  Hopefully, cmix
      // functions will _copy_ the array contents.
      else if (PyTuple_Check(obj) || PyList_Check(obj)) {
         // If tuple/list is final argument to function, treat its contents
         // as additional function arguments.
         if (i == nargs - 1) {
            int argCount = i;
            Arg *newargs = append_list_to_arglist(funcname, obj, rtcmixargs, &argCount);
            if (newargs == NULL)
               return NULL;
            delete [] rtcmixargs;
            rtcmixargs = newargs;
            numArgs = argCount;
         }
         else {
            int len;
            if (PyTuple_Check(obj))
               len = PyTuple_Size(obj);
            else
               len = PyList_Size(obj);
            double *data = (double *) malloc(sizeof(double) * len);
            if (data) {
               if (PyTuple_Check(obj)) {
                  for (int j = 0; j < len; j++) {
                     PyObject *item = PyTuple_GET_ITEM(obj, j);
                     if (PyNumber_Check(item))
                        data[j] = PyFloat_AsDouble(item);
                     else
                        data[j] = 0.0;
                  }
               }
               else {
                  for (int j = 0; j < len; j++) {
                     PyObject *item = PyList_GET_ITEM(obj, j);
                     if (PyNumber_Check(item))
                        data[j] = PyFloat_AsDouble(item);
                     else
                        data[j] = 0.0;
                  }
               }
            }
            if (data) {
               Array *array = (Array *) malloc(sizeof(Array));
               if (array) {
                  array->data = data;
                  array->len = len;
                  rtcmixargs[i] = array;
               }
               else
                  rtcmixargs[i] = 0.0;
            }
            else
               rtcmixargs[i] = 0.0;
         }
      }
      else {
         char buf[256];
         snprintf(buf, 256, "invalid argument type to '%s' (arg %d)", funcname, i);
         PyErr_SetString(PyExc_TypeError, buf);
         return NULL;
      }
   }

   Arg retval;
   int result = RTcmix::dispatch(funcname, rtcmixargs, numArgs, &retval);

   delete [] rtcmixargs;

   PyObject *retobj = NULL;

   if (result == 0) {
      switch (retval.type()) {
         case DoubleType:
            retobj = PyFloat_FromDouble(retval);
            break;
         case StringType:
            retobj = PyUnicode_FromString(retval);
            break;
         case HandleType:
            {
               OpaqueObject *newobj = newOpaqueObject(NULL);
               if (newobj == NULL) {
                  PyErr_SetString(PyExc_TypeError, "can't allocate new Handle");
                  return NULL;
               }
               newobj->handle = (Handle) retval;
               retobj = (PyObject *) newobj;
            }
            break;
         case ArrayType:
            break;
         default:
            break;
      }
   }

   return retobj;
}

